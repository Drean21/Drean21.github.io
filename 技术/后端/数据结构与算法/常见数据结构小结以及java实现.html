<!DOCTYPE html> <html><head>
<title>常见数据结构小结以及Java实现</title>
<base href="../../..">
<meta id="root-path" root-path="../../..">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
<meta charset="UTF-8">
<meta name="description" content="尘影迹痕 - 常见数据结构小结以及Java实现">
<meta property="og:title" content="常见数据结构小结以及Java实现">
<meta property="og:description" content="尘影迹痕 - 常见数据结构小结以及Java实现">
<meta property="og:type" content="website">
<meta property="og:url" content="https://blog.cytl2.eu.org/技术/后端/数据结构与算法/常见数据结构小结以及java实现.html">
<meta property="og:image" content="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png">
<meta property="og:site_name" content="尘影迹痕">
<meta name="author" content="lzy"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="https://blog.cytl2.eu.org/lib/rss.xml"><include src="lib/html/custom-head-content.html"></include><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script type="module" async="" id="graph-view-script" src="lib/scripts/graph-view.js"></script><script async="" id="graph-wasm-script" src="lib/scripts/graph-wasm.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="graph-render-worker-script" src="lib/scripts/graph-render-worker.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="tinycolor-script" src="lib/scripts/tinycolor.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="pixi-script" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.svg"><script async="" id="graph-data-script" src="lib/scripts/graph-data.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript><link rel="preload" href="lib/styles/snippets.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/snippets.css"></noscript><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:not(h1,h2,h3,h4,h5,h6):has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(const t of e){let e=t.getAttribute("src");try{const o=await fetch(e);if(!o.ok){console.log("Could not include file: "+e),t?.remove();continue}let l=await o.text(),n=document.createRange().createContextualFragment(l),c=Array.from(n.children);for(let e of c)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);t.before(n),t.remove(),console.log("Included file: "+e)}catch(o){t?.remove(),console.log("Could not include file: "+e,o);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script></head><body class="publish css-settings-manager theme-light show-inline-title h2-underline tbMH-yuan tbMH-qk tbMH-ds-cg tbMH-kd-ncc-jy is-focused"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="数组"><p>数组</p></h1><div class="heading-wrapper"><div class="heading-children"><div><p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力</p></div><div class="heading-wrapper"><h2 data-heading="一维数组在内存空间中是连续的" class="heading" id="一维数组在内存空间中是连续的"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>一维数组在内存空间中是连续的</h2><div class="heading-children"><div><p><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></p></div><div><p>数组可以方便的通过下标索引的方式获取到下标下对应的数据。</p></div><div><p>举一个字符数组的例子，如图所示：</p></div><div><p><img alt="算法通关数组" src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>需要两点注意的是</p></div><div><ul>
<li data-line="0"><strong>数组下标都是从0开始的。</strong></li>
<li data-line="1"><strong>数组内存空间的地址是连续的</strong></li>
</ul></div><div><p>正是<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></p></div><div><p>例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：</p></div><div><p><img alt="算法通关数组1" src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>而且大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。</p></div><div><p><strong>数组的元素是不能删的，只能覆盖。</strong></p></div><div><p>那么二维数组直接上图，大家应该就知道怎么回事了</p></div><div><p><img alt="算法通关数组2" src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%842.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div><div class="heading-wrapper"><h2 data-heading="那么二维数组在内存的空间地址是连续的么？" class="heading" id="那么二维数组在内存的空间地址是连续的么？"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>那么二维数组在内存的空间地址是连续的么？</h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="C++" class="heading" id="C++"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>C++</h3><div class="heading-children"><div><p>不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。</p></div><div><p>我们来做一个实验，C++测试代码如下：</p></div><div><pre class="language-php" tabindex="0"><code class="language-php is-loaded"><span class="token keyword type-declaration">void</span> <span class="token function">test_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword type-declaration">int</span> <span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
		<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string double-quoted-string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword type-declaration">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">test_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p>测试地址为</p></div><div><pre class="language-undefined" tabindex="0"><code class="language-undefined is-loaded">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
</code><button class="copy-code-button">复制</button></pre></div><div><p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p></div><div><p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节。</p></div><div><p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12。</p></div><div><p>如图：</p></div><div><p><img alt="数组内存" src="https://img-blog.csdnimg.cn/20210310150641186.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p><strong>所以可以看出在C++中二维数组在地址空间上是连续的</strong>。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="Java" class="heading" id="Java"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Java</h3><div class="heading-children"><div><p>像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机。</p></div><div><p>所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。</p></div><div><pre class="language-csharp" tabindex="0"><code class="language-csharp is-loaded"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">test_arr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token keyword">out</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p>输出的地址为：</p></div><div><pre class="language-perl" tabindex="0"><code class="language-perl is-loaded"><span class="token punctuation">[</span>I<span class="token variable">@7852</span>e922
<span class="token punctuation">[</span>I<span class="token variable">@4</span>e25154f
<span class="token punctuation">[</span>I<span class="token variable">@70</span>dea4e
<span class="token punctuation">[</span>I<span class="token variable">@5</span>c647e05
</code><button class="copy-code-button">复制</button></pre></div><div><p>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</p></div><div><p>所以Java的二维数组可能是如下排列的方式：</p></div><div><p><img alt="算法通关数组3" src="https://img-blog.csdnimg.cn/20201214111631844.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="链表" class="heading" id="链表">链表</h1><div class="heading-children"><div><p>什么是链表，链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p></div><div><p>链表的入口节点称为链表的头结点也就是head。</p></div><div><p>如图所示： <img alt="链表1" src="https://img-blog.csdnimg.cn/20200806194529815.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div class="heading-wrapper"><h2 data-heading="**链表的类型**" class="heading" id="**链表的类型**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>链表的类型</strong></h2><div class="heading-children"><div><p>接下来说一下链表的几种类型:</p></div><div class="heading-wrapper"><h3 data-heading="**单链表**" class="heading" id="**单链表**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>单链表</strong></h3><div class="heading-children"><div><p>刚刚说的就是单链表。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**双链表**" class="heading" id="**双链表**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>双链表</strong></h3><div class="heading-children"><div><p>单链表中的指针域只能指向节点的下一个节点。</p></div><div><p>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。</p></div><div><p>双链表 既可以向前查询也可以向后查询。</p></div><div><p>如图所示： <img alt="链表2" src="https://img-blog.csdnimg.cn/20200806194559317.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**循环链表**" class="heading" id="**循环链表**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>循环链表</strong></h3><div class="heading-children"><div><p>循环链表，顾名思义，就是链表首尾相连。</p></div><div><p>循环链表可以用来解决约瑟夫环问题。</p></div><div><p><img alt="链表4" src="https://img-blog.csdnimg.cn/20200806194629603.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="**链表的存储方式**" class="heading" id="**链表的存储方式**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>链表的存储方式</strong></h2><div class="heading-children"><div><p>了解完链表的类型，再来说一说链表在内存中的存储方式。</p></div><div><p>数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。</p></div><div><p>链表是通过指针域的指针链接在内存中各个节点。</p></div><div><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p></div><div><p>如图所示：</p></div><div><p><img alt="链表3" src="https://img-blog.csdnimg.cn/20200806194613920.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。</p></div></div></div><div class="heading-wrapper"><h2 data-heading="**链表的定义**" class="heading" id="**链表的定义**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>链表的定义</strong></h2><div class="heading-children"><div><p>平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了</p></div><div><p>而在面试的时候，一旦要自己手写链表，如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！</p></div><div><pre class="language-java" tabindex="0"><code class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结点的值</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>

    <span class="token comment">// 下一个结点</span>
    <span class="token class-name">ListNode</span> next<span class="token punctuation">;</span>

    <span class="token comment">// 节点的构造函数(无参)</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 节点的构造函数(有一个参数)</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 节点的构造函数(有两个参数)</span>
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">ListNode</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="**链表的操作**" class="heading" id="**链表的操作**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>链表的操作</strong></h2><div class="heading-children"><div class="heading-wrapper"><h3 data-heading="**删除节点**" class="heading" id="**删除节点**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>删除节点</strong></h3><div class="heading-children"><div><p>删除D节点，如图所示：</p></div><div><p><img alt="链表-删除节点" src="https://img-blog.csdnimg.cn/20200806195114541.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>只要将C节点的next指针 指向E节点就可以了。</p></div><div><p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p></div><div><p>是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。</p></div><div><p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**添加节点**" class="heading" id="**添加节点**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>添加节点</strong></h3><div class="heading-children"><div><p>如图所示：</p></div><div><p><img alt="链表-添加节点" src="https://img-blog.csdnimg.cn/20200806195134331.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p></div><div><p>但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="**性能分析**" class="heading" id="**性能分析**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>性能分析</strong></h2><div class="heading-children"><div><p>再把链表的特性和数组的特性进行一个对比，如图所示：</p></div><div><p><img alt="链表-链表与数据性能对比" src="https://img-blog.csdnimg.cn/20200806195200276.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。</p></div><div><p>链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。</p></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="哈希表" class="heading" id="哈希表">哈希表</h1><div class="heading-children"><div><p>首先什么是 哈希表，哈希表（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。</p></div><div><blockquote>
<p>哈希表是根据关键码的值而直接进行访问的数据结构。</p>
</blockquote></div><div><p>这么这官方的解释可能有点懵，其实直白来讲其实数组就是一张哈希表。</p></div><div><p>哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：</p></div><div><p><img alt="哈希表1" src="https://img-blog.csdnimg.cn/20210104234805168.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p></div><div><p>例如要查询一个名字是否在这所学校里。</p></div><div><p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p></div><div><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p></div><div><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p></div><div class="heading-wrapper"><h2 data-heading="**哈希函数**" class="heading" id="**哈希函数**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>哈希函数</strong></h2><div class="heading-children"><div><p>哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。</p></div><div><p>哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。</p></div><div><p><img alt="哈希表2" src="https://img-blog.csdnimg.cn/2021010423484818.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>如果hashCode得到的数值大于 哈希表的大小了，也就是大于tableSize了，怎么办呢？</p></div><div><p>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。</p></div><div><p>此时问题又来了，哈希表我们刚刚说过，就是一个数组。</p></div><div><p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。</p></div><div><p>接下来<strong>哈希碰撞</strong>登场</p></div><div class="heading-wrapper"><h3 data-heading="**哈希碰撞**" class="heading" id="**哈希碰撞**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>哈希碰撞</strong></h3><div class="heading-children"><div><p>如图所示，小李和小王都映射到了索引下标 1 的位置，<strong>这一现象叫做哈希碰撞</strong>。</p></div><div><p><img alt="哈希表3" src="https://img-blog.csdnimg.cn/2021010423494884.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**拉链法**" class="heading" id="**拉链法**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>拉链法</strong></h3><div class="heading-children"><div><p>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</p></div><div><p><img alt="哈希表4" src="https://img-blog.csdnimg.cn/20210104235015226.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>（数据规模是dataSize， 哈希表的大小为tableSize）</p></div><div><p>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**线性探测法**" class="heading" id="**线性探测法**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>线性探测法</strong></h3><div class="heading-children"><div><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p></div><div><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p></div><div><p><img alt="哈希表5" src="https://img-blog.csdnimg.cn/20210104235109950.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="**常见的三种哈希结构**" class="heading" id="**常见的三种哈希结构**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>常见的三种哈希结构</strong></h2><div class="heading-children"><div><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p></div><div><ul>
<li data-line="0">数组</li>
<li data-line="1">set （集合）</li>
<li data-line="2">map(映射)</li>
</ul></div><div><p>这里数组就没啥可说的了，我们来看一下set。</p></div><div><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p></div><div style="overflow-x: auto;"><table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table></div><div><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p></div><div style="overflow-x: auto;"><table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table></div><div><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p></div><div><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p></div><div><p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p></div><div><p>其他语言例如：<a data-tooltip-position="top" aria-label="https://cytl.ink/archives/1677311093901" rel="noopener" class="external-link is-unresolved" href="https://cytl.ink/archives/1677311093901" target="_self">java里的HashMap ，TreeMap</a> 都是一样的原理。可以灵活贯通。</p></div><div><p>虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。</p></div><div><p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？</p></div><div><p>实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。</p></div><div><p><img alt="哈希表6" src="https://img-blog.csdnimg.cn/20210104235134572.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div><div class="heading-wrapper"><h2 data-heading="**总结**" class="heading" id="**总结**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>总结</strong></h2><div class="heading-children"><div><p>总结一下，<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p></div><div><p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p></div><div><p>如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！</p></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="字符串" class="heading" id="字符串">字符串</h1><div class="heading-children"><div><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定。</p></div><div><p>字符串类类型的题目，往往想法比较简单，但是实现起来并不容易，复杂的字符串题目非常考验对代码的掌控能力。</p></div><div><p>双指针法是字符串处理的常客。</p></div><div><p>全局反转和局部反转的魔力~</p></div><div><p>KMP算法是字符串查找最重要的算法，但彻底理解KMP并不容易，我们已经写了五篇KMP的文章，不断总结和完善，最终才把KMP讲清楚。</p></div></div></div><div class="heading-wrapper"><h1 data-heading="栈和队列" class="heading" id="栈和队列">栈和队列</h1><div class="heading-children"><div><blockquote>
<p>来看看栈和队列不为人知的一面</p>
</blockquote></div><div><p>我想栈和队列的原理大家应该很熟悉了，队列是先进先出，栈是先进后出。</p></div><div><p>如图所示：</p></div><div><p><img alt="栈与队列理论1" src="https://img-blog.csdnimg.cn/20210104235346563.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>那么关于栈的问题，栈是容器吗？</p></div><div><p>有的同学可能仅仅知道有栈和队列这么个数据结构，却不知道底层实现，也不清楚所使用栈和队列和STL是什么关系。</p></div><div><p>所以这里我再给大家扫一遍基础知识，</p></div><div><p>首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。</p></div><div><p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p></div><div><p>那么来介绍一下，三个最为普遍的STL版本：</p></div><div><ol>
<li data-line="0">HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li data-line="1">P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li data-line="2">SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol></div><div><p>接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。</p></div><div><p>来说一说栈，栈先进后出，如图所示：</p></div><div><p><img alt="栈与队列理论2" src="https://img-blog.csdnimg.cn/20210104235434905.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。</p></div><div><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p></div><div><p>所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。</p></div><div><p>那么问题来了，STL 中栈是用什么容器实现的？</p></div><div><p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。</p></div><div><p><img alt="栈与队列理论3" src="https://img-blog.csdnimg.cn/20210104235459376.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">所以，栈和队列不是容器，而是容器适配器</p></div></div></div><div class="heading-wrapper"><h1 data-heading="二叉树" class="heading" id="二叉树">二叉树</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="**二叉树的种类**" class="heading" id="**二叉树的种类**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>二叉树的种类</strong></h2><div class="heading-children"><div><p>在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。</p></div><div class="heading-wrapper"><h3 data-heading="**满二叉树**" class="heading" id="**满二叉树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>满二叉树</strong></h3><div class="heading-children"><div><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p></div><div><p>如图所示：</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/20200806185805576.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。</p></div></div></div><div class="heading-wrapper"><h3 data-heading="**完全二叉树**" class="heading" id="**完全二叉树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>完全二叉树</strong></h3><div class="heading-children"><div><p>什么是完全二叉树？</p></div><div><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p></div><div><p><strong>大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。</strong></p></div><div><p>我来举一个典型的例子如题：</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/20200920221638903.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>相信不少同学最后一个二叉树是不是完全二叉树都中招了。</p></div><div><p><strong>之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</strong></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**二叉搜索树**" class="heading" id="**二叉搜索树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>二叉搜索树</strong></h3><div class="heading-children"><div><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，<strong>二叉搜索树是一个有序树</strong>。</p></div><div><ul>
<li data-line="0">若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li data-line="1">若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li data-line="2">它的左、右子树也分别为二叉排序树</li>
</ul></div><div><p>下面这两棵树都是搜索树 <img alt="img" src="https://img-blog.csdnimg.cn/20200806190304693.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="**平衡二叉搜索树**" class="heading" id="**平衡二叉搜索树**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>平衡二叉搜索树</strong></h3><div class="heading-children"><div><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p></div><div><p>如图：</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/20200806190511967.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。</p></div><div><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。</p></div><div><p><strong>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！</strong></p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="**二叉树的存储方式**" class="heading" id="**二叉树的存储方式**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>二叉树的存储方式</strong></h2><div class="heading-children"><div><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p></div><div><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p></div><div><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p></div><div><p>链式存储如图：</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/2020092019554618.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？</p></div><div><p>其实就是用数组来存储二叉树，顺序存储的方式如图：</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/20200920200429452.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>用数组来存储二叉树如何遍历的呢？</p></div><div><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i *2 + 1，右孩子就是 i* 2 + 2。</strong></p></div><div><p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p></div><div><p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p></div></div></div><div class="heading-wrapper"><h2 data-heading="**二叉树的遍历方式**" class="heading" id="**二叉树的遍历方式**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>二叉树的遍历方式</strong></h2><div class="heading-children"><div><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。</p></div><div><p>一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。</p></div><div><p>我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。</p></div><div><p>二叉树主要有两种遍历方式：</p></div><div><ol>
<li data-line="0">深度优先遍历：先往深走，遇到叶子节点再往回走。</li>
<li data-line="1">广度优先遍历：一层一层的去遍历。</li>
</ol></div><div><p><strong>这两种遍历是图论中最基本的两种遍历方式</strong>，后面在介绍图论的时候 还会介绍到。</p></div><div><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p></div><div><ul>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>深度优先遍历
<ul>
<li data-line="1">前序遍历（递归法，迭代法）</li>
<li data-line="2">中序遍历（递归法，迭代法）</li>
<li data-line="3">后序遍历（递归法，迭代法）</li>
</ul>
</li>
<li data-line="4"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>广度优先遍历
<ul>
<li data-line="5">层次遍历（迭代法）</li>
</ul>
</li>
</ul></div><div><p>在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。</p></div><div><p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong>，只要大家记住 前中后序指的就是中间节点的位置就可以了。</p></div><div><p>看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p></div><div><ul>
<li data-line="0">前序遍历：中左右</li>
<li data-line="1">中序遍历：左中右</li>
<li data-line="2">后序遍历：左右中</li>
</ul></div><div><p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p></div><div><p><img alt="img" src="https://img-blog.csdnimg.cn/20200806191109896.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div><div><p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p></div><div><p><strong>之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p></div><div><p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p></div><div><p><strong>这里其实我们又了解了栈与队列的一个应用场景了。</strong></p></div><div><p>具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。</p></div></div></div><div class="heading-wrapper"><h2 data-heading="**二叉树的定义**" class="heading" id="**二叉树的定义**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>二叉树的定义</strong></h2><div class="heading-children"><div><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p></div><div><p>C++代码如下：</p></div><div><pre class="language-java" tabindex="0"><code class="language-java is-loaded"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
  	<span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>
  	<span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>
  	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  	<span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    		<span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    		<span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
    		<span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
  	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p>大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。</p></div><div><p>这里要提醒大家要注意二叉树节点定义的书写方式。</p></div><div><p><strong>在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。</strong></p></div><div><p>因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！</p></div></div></div><div class="heading-wrapper"><h2 data-heading="**总结-题型**" class="heading" id="**总结-题型**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>总结-题型</strong></h2><div class="heading-children"><div><p>二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。</p></div><div><p><strong>说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。</strong></p></div><div><p>题目分类大纲如下：</p></div><div><p><img alt="二叉树大纲" src="https://img-blog.csdnimg.cn/20210219190809451.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"></p></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Java常用api和现成的数据结构" class="heading" id="Java常用api和现成的数据结构">Java常用api和现成的数据结构</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="数组" class="heading" id="数组"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>数组</h2><div class="heading-children"><div><p>数组的初始化：</p></div><div><pre class="language-java" tabindex="0"><code class="language-java is-loaded"><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>       
<span class="token keyword">int</span> size <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存放结果</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//默认全部初始化为-1</span>
</code><button class="copy-code-button">复制</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="字符串" class="heading" id="字符串"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>字符串</h2><div class="heading-children"><div><ul>
<li data-line="0">
<p>建议使用StringBiuder操作字符串，它不考虑线程安全，但性能高</p>
<p><a data-tooltip-position="top" aria-label="http://c.biancheng.net/view/5822.html" rel="noopener" class="external-link is-unresolved" href="http://c.biancheng.net/view/5822.html" target="_self">String、StringBuffer和StringBuilder类的区别 (</a><a data-tooltip-position="top" aria-label="http://biancheng.net/" rel="noopener" class="external-link is-unresolved" href="http://biancheng.net/" target="_self">biancheng.net</a><a data-tooltip-position="top" aria-label="http://c.biancheng.net/view/5822.html" rel="noopener" class="external-link is-unresolved" href="http://c.biancheng.net/view/5822.html" target="_self">)</a></p>
</li>
<li data-line="4">
<p>charAt(i)：得到字符串中的某个字符</p>
</li>
<li data-line="6">
<p>setCharAt(index, 字符);设置指定索引的字符内容</p>
</li>
<li data-line="8">
<p>deleteCharAt(index);删除指定索引的字符空间</p>
</li>
<li data-line="10">
<p>sb.reverse()：反转StringBuilder</p>
</li>
<li data-line="12">
<p>toCharArray()：将字符串转换成字符数组</p>
</li>
<li data-line="14">
<p><code>String没有length属性只有length()方法</code></p>
</li>
</ul></div></div></div><div class="heading-wrapper"><h2 data-heading="集合" class="heading" id="集合"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>集合</h2><div class="heading-children"><div><p><strong>List：</strong></p></div><div><ul>
<li data-line="0">Set set1 = new HashSet&lt;&gt;();</li>
<li data-line="1"><code>Arrays.sort(nums);快排（nlogN）</code></li>
<li data-line="2">Arrays.asList(nums[i], nums[left], nums[right]));返回一个 List 对象，这个 List 对象包含了这三个元素。</li>
<li data-line="3">contain()：是否包含</li>
<li data-line="4"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Stream()流基础操作流程以及mapToInt等转换流类型的方法以及toArray等流输出方法
<ul>
<li data-line="5">示例：resSet.stream().mapToInt(x -&gt; x).toArray();</li>
</ul>
</li>
</ul></div><div><p><strong>Map：</strong></p></div><div><ul>
<li data-line="0">Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</li>
<li data-line="1">containsKey(key);是否包含key</li>
<li data-line="2">get(key);</li>
</ul></div></div></div><div class="heading-wrapper"><h2 data-heading="栈" class="heading" id="栈"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>栈</h2><div class="heading-children"><div><p>可以使用双向队列来实现栈 ——当然部分情况下更好用</p></div><div><ul>
<li data-line="0">stack = new Stack&lt;&gt;(); 创建一个栈，但推荐直接使用~</li>
<li data-line="1">push()入栈</li>
<li data-line="2">pop()出栈</li>
<li data-line="3">peek()栈顶元素（下一个要出栈的元素）</li>
<li data-line="4">isEmpty()栈是否为空</li>
</ul></div></div></div><div class="heading-wrapper"><h2 data-heading="**队列**" class="heading" id="**队列**"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><strong>队列</strong></h2><div class="heading-children"><div><p><a data-tooltip-position="top" aria-label="https://blog.csdn.net/qq_27184497/article/details/116093422" rel="noopener" class="external-link is-unresolved" href="https://blog.csdn.net/qq_27184497/article/details/116093422" target="_self">JAVA队列（ Queue ) 详解_</a>队列是接口，实现通过多态特性new对象的时候指定具体的实现</p></div><div><ul>
<li data-line="0">push(x) -- 将一个元素放入队列的尾部。</li>
<li data-line="1">poll() -- 从队列首部移除元素。</li>
<li data-line="2">peek() -- 返回队列首部的元素。</li>
<li data-line="3">isEmpty() -- 返回队列是否为空。</li>
<li data-line="4">deque.getLast()：获取队列最后一个元素</li>
<li data-line="5">deque.removeLast();移除队列最后一个元素</li>
<li data-line="6">deque.peek();获取队头元素</li>
<li data-line="7"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>优先级队列实现：
<ul>
<li data-line="8">PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1,pair2)-&gt;pair1[1]-pair2[1]);</li>
<li data-line="9"><code>return left&lt;right</code> 左-右&lt;0,就是从小到大。</li>
</ul>
</li>
</ul></div></div></div><div class="heading-wrapper"><h2 data-heading="Array.sort()" class="heading" id="Array.sort()"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Array.sort()</h2><div class="heading-children"><div><blockquote>
<p>经常用到，刷题多了你就知道有时候解题第一步就是要将数组/集合排序，有序后才能更加快乐的解题！</p>
</blockquote></div><div><p>在 Java 中，<code>Arrays.sort()</code> 方法使用的是一种改进版的快速排序算法（dual pivot quicksort），其时间复杂度为 O(n log n)。</p></div><div><ul>
<li data-line="0">
<p>对于较小的数组（通常为小于47个元素），它会使用插入排序来排序，因为插入排序在小规模数据上有较好的性能。</p>
</li>
<li data-line="2">
<p>但是，对于大的数据集合，它会使用快速排序。</p>
</li>
</ul></div><div><p>因此，<code>Arrays.sort()</code> 的时间复杂度取决于排序数组的大小，但是在平均情况下，它是 <mark>O(n log n)</mark> 级别的。</p></div><div class="heading-wrapper"><h3 data-heading="用例" class="heading" id="用例"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>用例</h3><div class="heading-children"><div><pre class="language-java" tabindex="0"><code class="language-java is-loaded"><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">abs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div><div><p>等效Sream流操作：</p></div><div><pre class="language-java" tabindex="0"><code class="language-java is-loaded">nums <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">::</span><span class="token function">abs</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">intValue</span><span class="token punctuation">)</span>
             <span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">复制</button></pre></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="graph-view-wrapper"><div class="sidebar-section-header">Interactive Graph</div><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" class="hide" width="512px" height="512px"></canvas>
		</div>
		</div></div><div class="outline-tree tree-container"><div class="tree-item nav-folder mod-root" data-depth="0"><div class="tree-item-self nav-folder-title"><div class="tree-item-inner nav-folder-title-content">Table Of Contents</div><button class="clickable-icon nav-action-button tree-collapse-all" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-item-children nav-folder-children"><div class="nav-folder-spacer"></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#数组" data-path="#数组"><div class="tree-item-inner heading-link" heading-name="数组">数组</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#一维数组在内存空间中是连续的" data-path="#一维数组在内存空间中是连续的"><div class="tree-item-inner heading-link" heading-name="一维数组在内存空间中是连续的">一维数组在内存空间中是连续的</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#那么二维数组在内存的空间地址是连续的么？" data-path="#那么二维数组在内存的空间地址是连续的么？"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="那么二维数组在内存的空间地址是连续的么？">那么二维数组在内存的空间地址是连续的么？</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#C++" data-path="#C++"><div class="tree-item-inner heading-link" heading-name="C++">C++</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#Java" data-path="#Java"><div class="tree-item-inner heading-link" heading-name="Java">Java</div></a><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#链表" data-path="#链表"><div class="tree-item-inner heading-link" heading-name="链表">链表</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**链表的类型**" data-path="#**链表的类型**"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="**链表的类型**"><strong>链表的类型</strong></div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**单链表**" data-path="#**单链表**"><div class="tree-item-inner heading-link" heading-name="**单链表**"><strong>单链表</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**双链表**" data-path="#**双链表**"><div class="tree-item-inner heading-link" heading-name="**双链表**"><strong>双链表</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**循环链表**" data-path="#**循环链表**"><div class="tree-item-inner heading-link" heading-name="**循环链表**"><strong>循环链表</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**链表的存储方式**" data-path="#**链表的存储方式**"><div class="tree-item-inner heading-link" heading-name="**链表的存储方式**"><strong>链表的存储方式</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**链表的定义**" data-path="#**链表的定义**"><div class="tree-item-inner heading-link" heading-name="**链表的定义**"><strong>链表的定义</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**链表的操作**" data-path="#**链表的操作**"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="**链表的操作**"><strong>链表的操作</strong></div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**删除节点**" data-path="#**删除节点**"><div class="tree-item-inner heading-link" heading-name="**删除节点**"><strong>删除节点</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**添加节点**" data-path="#**添加节点**"><div class="tree-item-inner heading-link" heading-name="**添加节点**"><strong>添加节点</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**性能分析**" data-path="#**性能分析**"><div class="tree-item-inner heading-link" heading-name="**性能分析**"><strong>性能分析</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#哈希表" data-path="#哈希表"><div class="tree-item-inner heading-link" heading-name="哈希表">哈希表</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**哈希函数**" data-path="#**哈希函数**"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="**哈希函数**"><strong>哈希函数</strong></div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**哈希碰撞**" data-path="#**哈希碰撞**"><div class="tree-item-inner heading-link" heading-name="**哈希碰撞**"><strong>哈希碰撞</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**拉链法**" data-path="#**拉链法**"><div class="tree-item-inner heading-link" heading-name="**拉链法**"><strong>拉链法</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**线性探测法**" data-path="#**线性探测法**"><div class="tree-item-inner heading-link" heading-name="**线性探测法**"><strong>线性探测法</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**常见的三种哈希结构**" data-path="#**常见的三种哈希结构**"><div class="tree-item-inner heading-link" heading-name="**常见的三种哈希结构**"><strong>常见的三种哈希结构</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**总结**" data-path="#**总结**"><div class="tree-item-inner heading-link" heading-name="**总结**"><strong>总结</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#字符串" data-path="#字符串"><div class="tree-item-inner heading-link" heading-name="字符串">字符串</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#栈和队列" data-path="#栈和队列"><div class="tree-item-inner heading-link" heading-name="栈和队列">栈和队列</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#二叉树" data-path="#二叉树"><div class="tree-item-inner heading-link" heading-name="二叉树">二叉树</div></a><div class="tree-item-children"><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**二叉树的种类**" data-path="#**二叉树的种类**"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="**二叉树的种类**"><strong>二叉树的种类</strong></div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**满二叉树**" data-path="#**满二叉树**"><div class="tree-item-inner heading-link" heading-name="**满二叉树**"><strong>满二叉树</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**完全二叉树**" data-path="#**完全二叉树**"><div class="tree-item-inner heading-link" heading-name="**完全二叉树**"><strong>完全二叉树</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**二叉搜索树**" data-path="#**二叉搜索树**"><div class="tree-item-inner heading-link" heading-name="**二叉搜索树**"><strong>二叉搜索树</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**平衡二叉搜索树**" data-path="#**平衡二叉搜索树**"><div class="tree-item-inner heading-link" heading-name="**平衡二叉搜索树**"><strong>平衡二叉搜索树</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**二叉树的存储方式**" data-path="#**二叉树的存储方式**"><div class="tree-item-inner heading-link" heading-name="**二叉树的存储方式**"><strong>二叉树的存储方式</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**二叉树的遍历方式**" data-path="#**二叉树的遍历方式**"><div class="tree-item-inner heading-link" heading-name="**二叉树的遍历方式**"><strong>二叉树的遍历方式</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**二叉树的定义**" data-path="#**二叉树的定义**"><div class="tree-item-inner heading-link" heading-name="**二叉树的定义**"><strong>二叉树的定义</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**总结-题型**" data-path="#**总结-题型**"><div class="tree-item-inner heading-link" heading-name="**总结-题型**"><strong>总结-题型</strong></div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#Java常用api和现成的数据结构" data-path="#Java常用api和现成的数据结构"><div class="tree-item-inner heading-link" heading-name="Java常用api和现成的数据结构">Java常用api和现成的数据结构</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#数组" data-path="#数组"><div class="tree-item-inner heading-link" heading-name="数组">数组</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#字符串" data-path="#字符串"><div class="tree-item-inner heading-link" heading-name="字符串">字符串</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#集合" data-path="#集合"><div class="tree-item-inner heading-link" heading-name="集合">集合</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#栈" data-path="#栈"><div class="tree-item-inner heading-link" heading-name="栈">栈</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#**队列**" data-path="#**队列**"><div class="tree-item-inner heading-link" heading-name="**队列**"><strong>队列</strong></div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#Array.sort()" data-path="#Array.sort()"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Array.sort()">Array.sort()</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="技术/后端/数据结构与算法/常见数据结构小结以及java实现.html#用例" data-path="#用例"><div class="tree-item-inner heading-link" heading-name="用例">用例</div></a><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>